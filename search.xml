<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Typora+PicGo+SM.MS图床打造博客神器</title>
      <link href="/Typora-PicGo-Blog/"/>
      <url>/Typora-PicGo-Blog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  本篇主要介绍使用<code>Typora</code>写文章时，将图片粘贴到文本中，自动将图片上传到图床，并且自动将图片地址替换成图床中图片的网络地址！(本教程以<strong>Windows</strong>平台为例，MAC OS和Linux原理差不多)</p><p>  花了几天时间用<a href="https://www.xmind.net/" target="_blank" rel="noopener">XMind</a>把<a href="http://staff.ustc.edu.cn/~llxx/cod/reference_books/tang.pdf" target="_blank" rel="noopener">《计算机组成原理》</a>的思维导图整理完毕，准备用<code>Xmind</code>自带的导出<code>.md</code>文件的方法把总结的每一章放到博客上，但奈何<code>Xmind</code>导出的<code>.md</code>文件不带图片。于是我机智地导出为<code>Word</code>格式，<code>Word</code>格式可以把图片一起导出来。但当下博客平台的编辑器很少支持<code>Word</code>格式导入——<strong>知乎</strong>支持<code>word</code>导入，<strong>CSDN</strong>和<strong>简书</strong>目前还都不能直接<code>Word</code>导入。而且我还需要把文档放入到我的<strong>个人博客</strong><a href="https://sunmengxin.cn">https://sunmengxin.cn</a>，所以把文档转成<code>MarkDown</code>格式就很有必要。（这里备注一下，我用的方法是将Word里的内容整体粘贴到Typora，包括图片。天真的我以为就此大功告成，但后来发现XMind导出的Word中的图片都是压缩过的，模糊的一批<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8">😭</span>）</p><p>  格式转换存在最大的问题就是图片如何转存，想把文章放到多个平台，最好的方式就是找个图床专门存放图片，写文章时直接引用图床里图片的<code>url</code>。但图片单张上传再去粘贴复制图片的地址相当麻烦，就想着能不能直接粘贴自动上传。在网上找了找发现还真有，话不多说，进入正题：</p><blockquote><p>所需工具：</p><ul><li>Typora编辑器<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></li><li>SM.MS图床<a href="https://sm.ms/" target="_blank" rel="noopener">https://sm.ms/</a></li><li>PicGo<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></li><li>PicGo的SM.MS插件<a href="https://github.com/xlzy520/picgo-plugin-smms-user" target="_blank" rel="noopener">https://github.com/xlzy520/picgo-plugin-smms-user</a></li></ul></blockquote><h2 id="1-下载安装Typora"><a href="#1-下载安装Typora" class="headerlink" title="1.下载安装Typora"></a>1.下载安装Typora</h2><p>  作为一款优秀的的跨平台<code>MarkDown</code>编辑器，这里就不多介绍了，去<a href="https://typora.io/" target="_blank" rel="noopener">官网</a>下载适用于自己的版本并安装：</p><img src="https://i.loli.net/2020/02/27/WFSuyjLtzalP5GB.gif"><p><code>Typora</code>有各式各样的主题可供选择，根据需求选择自己喜欢的主题即可：</p><img src="https://i.loli.net/2020/02/27/Pt648D593dOglwM.png"><h2 id="2-注册登录SM-MS图床"><a href="#2-注册登录SM-MS图床" class="headerlink" title="2.注册登录SM.MS图床"></a>2.注册登录SM.MS图床</h2><p>  本来一直用的<a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床</a>，速度还同i挺快的，而且不限制上传频率和数量，奈何其既不支持自定义图片名称，又不支持自动上传的插件，只能一张一张上传，比较麻烦：</p><blockquote><p>官网地址：<a href="https://link.zhihu.com/?target=https%3A//imgchr.com/">https://imgchr.com</a></p><p>简介：支持免注册上传图片，永久存储，支持HTTPS加密访问和调用图片，提供多种图片链接格式，成立于2011年</p><p>限制：最大10M  </p></blockquote><p><code>SM.MS</code>也是国内用户比较青睐的一个图床平台：</p><blockquote><p>官网地址：<a href="https://link.zhihu.com/?target=https%3A//sm.ms/">https://sm.ms</a></p><p>特点：永久存储免注册，图片链接支持https，可以删除上传的图片，提供多种图片链接格式，建立于2015年，速度比路过图床慢</p><p>图片上传限制：每个图片最大5M，每分钟最多上传10张</p></blockquote><p>进入<code>SM.MS</code><a href="https://sm.ms/" target="_blank" rel="noopener">官网</a>，点击<code>User</code>-&gt;<code>Login</code>注册登录，登录后点击相同的位置，进入<code>Dashboard</code>可以看到有5个G的免费空间:</p><img src="https://i.loli.net/2020/02/27/54EG27QNPhXJO9S.png"><p>然后点击左侧<code>API Token</code>-&gt;<code>Generate Secret Token</code>获取自己的密钥,等下使用：</p><img src="https://i.loli.net/2020/02/27/Bid84btMXSomZUs.png"><h2 id="3-安装PicGo"><a href="#3-安装PicGo" class="headerlink" title="3.安装PicGo"></a>3.安装PicGo</h2><p>  进入<code>PicGo</code>的<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">GitHub主页</a>下载适用于自己平台的安装包，安装完成后发现默认图床中并没有<code>SM.MS</code>图床的选项，这是需要下载一些插件，可直接再安装程序里搜索相关插件，这里安装两个插件：</p><blockquote><p><code>picgo-plugin-smms-user</code>：为 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> 开发的一款插件，新增了<a href="https://sm.ms/home/" target="_blank" rel="noopener">SM.MS注册用户</a> 图床。</p><p><code>picgo-plugin-quick-capture</code>：这个插件可实现自定义截图快捷键，并且将图片自动上传到图床获取图片的<code>url</code>地址，非常的方便易用。</p></blockquote><p>进入安装好的<code>PicGo</code>程序，点击左侧<code>插件设置</code>-&gt;<code>搜索smms插件</code>-&gt;<code>点击安装</code>:</p><img src="https://i.loli.net/2020/02/27/SNa49yBT7GEugev.png"><p>同样的方式安装<code>picgo-plugin-quick-capture</code>插件：</p><img src="https://i.loli.net/2020/02/27/O3t8z4pACy7dkwv.png"><p>  到这一步还没有结束，<strong>由于<code>SM.MS</code>官方不再支持V1版本，需要使用<a href="https://github.com/xlzy520/picgo-plugin-smms-user" target="_blank" rel="noopener">smms-user</a>插件</strong>替换刚刚安装的插件文件夹。点击这个链接<a href="https://github.com/xlzy520/picgo-plugin-smms-user" target="_blank" rel="noopener">https://github.com/xlzy520/picgo-plugin-smms-user</a>，将其克隆到本地，然后找到插件的安装位置，一般在：</p><blockquote><p>Windows: `%APPDATA%\picgo\</p><p>Linux: <code>$XDG_CONFIG_HOME/picgo/</code> or <code>~/.config/picgo/</code></p><p>macOS: <code>~/Library/Application\ Support/picgo/</code></p></blockquote><p>  例如我的在<code>C:\Users\MengXin\AppData\Roaming\picgo\node_modules</code>,将其中的<code>picgo-plugin-smms-user</code>文件夹里的内容<strong>全部删除替换成刚刚我们克隆下来的文件里面的内容</strong>:</p><img src="https://i.loli.net/2020/02/27/1XPluKb6n2kHGCc.png"><p>然后打开图床设置中的<code>SM.MS用户登录</code>-&gt;<code>输入自己的密钥</code>:</p><img src="https://i.loli.net/2020/02/27/IqHUahe5XQv8WcT.png"><p>最后一步打开<code>PicGo设置</code>-&gt;将监听端口改为<strong><code>36677</code></strong>：</p><img src="https://i.loli.net/2020/02/27/VvcXfnAC7WSUMR3.png"><p>这里可以先测试一下，拖进来一张图片或者截图上传：<br><img src="https://i.loli.net/2020/02/29/qUamZkSrHf9hYWX.png"></p><h2 id="4-配置Typora"><a href="#4-配置Typora" class="headerlink" title="4.配置Typora"></a>4.配置Typora</h2><p>  打开<code>Typora</code>-&gt;<code>文件</code>-&gt;<code>偏好设置</code>-&gt;<code>图像</code>，设置<code>上传图片</code>以及<code>上传规则</code>，然后设置<code>上传服务</code>和<code>PicGo 路径</code>，最后点击<code>验证图片上传选项</code>看是否成功(若不行，重启软件)：</p><img src="https://i.loli.net/2020/02/27/yBUnwtLRVh8elz1.png"><p>  这里我配置之后尝试发现它会失败，为了方便我上传的图片本低也有一份备份，我后来改了设置——如下图，改了设置依然可以用，用法可参考最后一步：<br><img src="https://i.loli.net/2020/02/29/a4fQIDLZdw78u6O.png"></p><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5.使用"></a>5.使用</h2><p>此时就有两种截图直接上传方法可供使用：</p><ul><li>方法一：修改<code>PicGo</code>中的截图快捷键设置为 <kbd>Ctrl</kbd>+<kbd>Win</kbd>+ <kbd>A</kbd> ，然后使用快捷键截图会自动上传到图床，此时只要在文本框中粘贴就得到了图片的<code>Url</code>:</li></ul><img src="https://i.loli.net/2020/02/27/V8LjSnE9ZeBRor2.png"><ul><li>方法2：使用<code>Windows</code>自带的快捷键 <kbd>Ctrl</kbd>+<kbd>Win</kbd>+ <kbd>S</kbd> 截图，然后直接在文本框里 <kbd>Ctrl</kbd>+<kbd>V</kbd> 粘贴图片，然后再图片上<code>右击</code>点击<code>上传图片</code>。</li></ul><br><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>  <a href="https://picgo.github.io/PicGo-Doc/zh/guide/#应用说明" target="_blank" rel="noopener"><code>PicGo</code>说明</a><br>  <a href="https://zhuanlan.zhihu.com/p/35270383" target="_blank" rel="noopener">盘点国内免费好用的图床</a><br>  <a href="https://sspai.com/post/58223" target="_blank" rel="noopener">PicGo v2.2 更新，快捷键系统与一波插件推荐</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> 图床 </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware15安装MAC OS10.14（新版详细）</title>
      <link href="/vmware15-install-macos/"/>
      <url>/vmware15-install-macos/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  一直想搞个黑苹果玩玩，奈何黑苹果双系统的操作步骤太过复杂，就决定先装个虚拟机体验一下。之前不想在Windows和Ubuntu之间来回切换系统，也曾用虚拟机装过Ubuntu。虚拟机的好处就是方便且易于复制，但缺点也很明显，依附于Windows系统，不能享用电脑硬件的100%的硬件资源。</p><p>效果如下：<br><img src="https://img-blog.csdnimg.cn/20200220114655114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="1-工具准备"><a href="#1-工具准备" class="headerlink" title="1.工具准备"></a>1.工具准备</h2><ul><li>VMware15</li><li>unlocker解锁工具（可能需要Python环境，我之前安装过Python3.7）</li><li>MAC OS Mojave 10.14懒人版</li></ul><p>安装所需的软件<a href="https://pan.baidu.com/s/1mvDbcvaLtUz3eXQ6tYVRrg" target="_blank" rel="noopener">https://pan.baidu.com/s/1mvDbcvaLtUz3eXQ6tYVRrg</a>;密码<code>8tc8</code>。</p><h2 id="2-安装VMware15"><a href="#2-安装VMware15" class="headerlink" title="2.安装VMware15"></a>2.安装VMware15</h2><p>  双击安装包里的<code>VMware-workstation-full-15.0.0-10134415.exe</code>，按照引导安装完程序，可更换安装位置，安装完成后输入激活码<code>YG5H2-ANZ0H-M8ERY-TXZZZ-YKRV8</code>。打开查看激活情况：<br><img src="https://img-blog.csdnimg.cn/2020022011535067.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="3-使用unlocker解锁VMware里的MAC-OS选项"><a href="#3-使用unlocker解锁VMware里的MAC-OS选项" class="headerlink" title="3.使用unlocker解锁VＭware里的MAC OS选项　"></a>3.使用unlocker解锁VＭware里的MAC OS选项　</h2><p>VＭware默认没有MAC的选项，需要使用<code>unlocker</code>解锁：<br>1.关闭 <code>VMware Workstation Pro</code>，关闭 <code>VMware</code> 服务：<br><img src="https://img-blog.csdnimg.cn/20200220120012899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>2.把下载好的 <code>unlocker</code> 解压到不含中文目录的路径，<strong>管理员模式</strong>下运行 <code>win-install.cmd</code> 安装：<br><img src="https://img-blog.csdnimg.cn/20200220120222837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>这个脚本文件会自动解锁<code>VMware</code>,接下来就能进行正式操作了 :sunglasses:  </p><h2 id="4-创建虚拟机安装MAC-OS"><a href="#4-创建虚拟机安装MAC-OS" class="headerlink" title="4.创建虚拟机安装MAC OS"></a>4.创建虚拟机安装MAC OS</h2><p>1.打开 <code>VMware</code> ，创建新虚拟机，选择<code>典型</code><br><img src="https://img-blog.csdnimg.cn/20200220120806662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>2.选择第二个安装程序光盘影响文件：<br><img src="https://img-blog.csdnimg.cn/20200220121022117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>3.浏览到相应目录，右下角选择所有文件，选择相应的<code>.cdr</code>文件：<br><img src="https://img-blog.csdnimg.cn/20200220120928760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>4.选择<code>Apple Mac</code>和相应的版本，版本要对应：<br><img src="https://img-blog.csdnimg.cn/20200220121346559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>5.填写名称和安装路径（选择英文路径）：<br><img src="https://img-blog.csdnimg.cn/20200220121531446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>6.大小默认即可，下面选项建议选择第一个：<br><img src="https://img-blog.csdnimg.cn/20200220121811118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>7.硬件资源可根据需求调整，也可以之后调整：<br><img src="https://img-blog.csdnimg.cn/20200220122032690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>8.确定后不要急着打开虚拟机，找到刚才虚拟机系统文件路径下的<code>MAC OS 10.14.vmx</code>，用记事本打开，在 <code>smc.present = "TRUE"</code>后添加（<code>smc.version = "0"</code>）(建议您复制，不包括括号) 后保存。<br><img src="https://img-blog.csdnimg.cn/20200220122424524.png" alt=""><br>9.打开虚拟机，等待进度条加载完毕:<br><img src="https://img-blog.csdnimg.cn/20200220122533219.png" alt=""><br>10.语言选择简体中文，同意条款，继续安装；直到显示没有足够空间，点击屏幕上方的 “<code>实用工具</code> -&gt; <code>磁盘工具</code>”。选中 “ <code>vmware workstation SATA hard drive media</code> ”，点击 “抹掉”。<br><img src="https://img-blog.csdnimg.cn/20200220123102272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>11.退出 “磁盘工具”，再次进行安装，此时选择新出现的分区，开始安装，<br><img src="https://img-blog.csdnimg.cn/20200220123447831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>12.待安装完成，国家选择中国，键盘选择简体中文，不传输信息，<code>apple id</code>稍后设置，创建用户名和密码。<br><img src="https://img-blog.csdnimg.cn/20200220123537934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>13.全部设置完毕即可进入系统，进入桌面右击右上角光盘图标，选择<code>推出XXX</code>：<br><img src="https://img-blog.csdnimg.cn/2020022012415219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="5-安装VMware-Tools"><a href="#5-安装VMware-Tools" class="headerlink" title="5.安装VMware Tools"></a>5.安装VMware Tools</h2><p>1.下载<code>VMTool(New).iso</code>，链接<a href="https://pan.baidu.com/s/1eFOodlbLAfhWuUD8gPV5XA" target="_blank" rel="noopener">https://pan.baidu.com/s/1eFOodlbLAfhWuUD8gPV5XA</a>,密码<code>ow6i</code>，进入VMware点击右下角光盘形状按钮，点击设置：<br><img src="https://img-blog.csdnimg.cn/2020022012394494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>2.点击<code>CD/DVD</code>,点击浏览，选择刚刚下载的<code>.iso</code>文件，确定：<br><img src="https://img-blog.csdnimg.cn/20200220131320674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>3.再次进入VMware点击右下角光盘形状按钮，点击<strong>连接</strong>，点击安装<code>VMware Tools</code>：<br><img src="https://img-blog.csdnimg.cn/20200220131921352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>4.安装过程弹出权限需求，选择允许：<br><img src="https://img-blog.csdnimg.cn/20200220132109849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="6-解决App-Store无法登录使用问题："><a href="#6-解决App-Store无法登录使用问题：" class="headerlink" title="6.解决App Store无法登录使用问题："></a>6.解决App Store无法登录使用问题：</h2><p>  此问题的主要原因是没有正确的序列号，而 <code>Apple</code> 会检测此信息，因此我们要解决此问题，只要解决序列号问题即可。<br>1.虚拟机设置网络连接模式为桥接模式:<br><img src="https://img-blog.csdnimg.cn/20200220133510707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>2.启动虚拟机，然后下载运行 <code>Chameleon Wizard</code>，<a href="https://pan.baidu.com/s/1a-1D5npr2sDtRHpwo5X7ww" target="_blank" rel="noopener">https://pan.baidu.com/s/1a-1D5npr2sDtRHpwo5X7ww</a><br>提取码：<code>g3vg</code>，点击编辑：<br><img src="https://img-blog.csdnimg.cn/20200220132954583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>3.<code>编辑</code> -&gt; <code>预制的 smbioses 模版</code> -&gt; <code>根据真机的 CPU 型号选个最相近的模版</code>，生成成功后点另存为，导出设备信息文件：<br><img src="https://img-blog.csdnimg.cn/20200220133105265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>4.关闭虚拟机，编辑虚拟机对应的 <code>macOS 10.14.vmx</code>文件，用前面生成的信息，加入这么几行（cpu差不多的直接复制下面也可）：</p><pre class="line-numbers language-c"><code class="language-c">board<span class="token operator">-</span>id<span class="token punctuation">.</span>reflectHost <span class="token operator">=</span> <span class="token string">"FALSE"</span>board<span class="token operator">-</span>id <span class="token operator">=</span> <span class="token string">"Mac-94245B3640C91C81"</span>hw<span class="token punctuation">.</span>model<span class="token punctuation">.</span>reflectHost <span class="token operator">=</span> <span class="token string">"FALSE"</span>hw<span class="token punctuation">.</span>model <span class="token operator">=</span> <span class="token string">"MacBook Pro"</span>serialNumber<span class="token punctuation">.</span>reflectHost <span class="token operator">=</span> <span class="token string">"FALSE"</span>serialNumber <span class="token operator">=</span> <span class="token string">"C02JJ8B3DH2G"</span>smbios<span class="token punctuation">.</span>reflectHost <span class="token operator">=</span> <span class="token string">"FALSE"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：如果<code>macOS 10.14.vmx</code> 文件中含有 <code>board-id.reflectHost = "TRUE"</code>之类的字样就把它删掉，之后就可以在App Store尽情下载了。</p><h2 id="7-macOS-10-14-安装允许任何来源没了怎么开启"><a href="#7-macOS-10-14-安装允许任何来源没了怎么开启" class="headerlink" title="7.macOS 10.14 安装允许任何来源没了怎么开启"></a>7.macOS 10.14 安装允许任何来源没了怎么开启</h2><p>点击MAC桌面下方<code>启动台</code>-&gt;<code>其他</code>-&gt;<code>终端</code>：输入<code>sudo spctl --master-disable</code>，输入密码即可。<br><img src="https://img-blog.csdnimg.cn/20200220134049369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>  <a href="http://www.carrotchou.blog/18689.html" target="_blank" rel="noopener">1.VMware 虚拟机安装 macOS 10.14 教程</a><br>  <a href="https://blog.csdn.net/qq_40147863/article/details/84797618" target="_blank" rel="noopener">2.VMware 15 安装 MAC OS 10.13 原版（详细图文教程）</a><br>  <a href="https://blog.csdn.net/galaxy_yyg/article/details/82891044" target="_blank" rel="noopener">3.VMWare15 安装 Mac OS 系统</a><br>  <a href="https://www.jianshu.com/p/dea92fbf00a4" target="_blank" rel="noopener">4.VMware虚拟机安装macOS系统小结</a><br>  <a href="http://bbs.pcbeta.com/viewthread-1729408-1-1.html" target="_blank" rel="noopener">5.原版系统APP制作DMG系统盘详细过程</a><br>  <a href="http://bbs.pcbeta.com/viewthread-1652838-1-4.html" target="_blank" rel="noopener">6.如何制作自己的macOS系统的cdr懒人包</a><br>  <a href="https://bbs.feng.com/read-htm-tid-10406997.html" target="_blank" rel="noopener">7.制作OS X安装U盘</a><br>  <a href="https://blog.csdn.net/aaron_zhang939/article/details/78616873" target="_blank" rel="noopener">8.VM虚拟机不能上网的问题解决</a><br>  <a href="http://bbs.pcbeta.com/viewthread-1816057-1-1.html" target="_blank" rel="noopener">9.制作VMware Workstation可用的macOS Mojave 10.14.X安装镜像教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> MAC OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode代替Arduino IDE实现代码补全文件跳转（详细）</title>
      <link href="/vscode-replace-arduino/"/>
      <url>/vscode-replace-arduino/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  对于编写<code>Arduino</code>程序的小伙伴，<code>Arduino IDE</code>虽然简单易上手，但当代码量提高或者想查看源码定义时就显得力不从心，因此找到一款能够代替<code>Arduino ID</code>E的编辑器就很有必要。能够支持<code>Arduino</code>的编辑器有很多，像之前的<code>Visual Studio</code>，<code>GitHub</code>的<code>Atom</code>以及微软的<code>VScode</code>等。这里我们选择<code>VScode</code>，它轻量且很多插件，比较为大家所熟知。<br>  <code>VScode</code>编辑<code>Arduino</code>程序支持<strong>代码高亮，代码补全，转到定义，文件跳转</strong>等，对于提高敲代码速度以及查看源码或者库文件实乃必备工具。而且<code>VScode</code>可以跨平台使用，<code>Windows</code>，<code>MAC</code>，<code>Linux</code>都支持。</p><p>话不多说，先看效果：<br><img src="https://img-blog.csdnimg.cn/202002151243131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt="VScode中的界面"></p><p><img src="https://img-blog.csdnimg.cn/20200215124535290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt="Arduino中的界面"></p><h2 id="1-Arduino-IDE的安装与使用"><a href="#1-Arduino-IDE的安装与使用" class="headerlink" title="1.Arduino IDE的安装与使用"></a>1.Arduino IDE的安装与使用</h2><p>  由于这些编辑器还是要依赖<code>Arduino IDE</code>，首先安装<code>Arduino IDE</code>和<code>VScode</code>。先进入<code>Arduino</code>的<a href="https://www.arduino.cc/en/Main/Software" target="_blank" rel="noopener">官网</a>，下载<code>Windows Installer</code>安装版本,然后默认安装就行，有问题可以参考其他的安装教程。安装完成后将<code>Arduino IDE</code>加入到环境变量（这一步可以先跳过，到后面有问题再来配置也不迟），<code>我的电脑</code>右键-&gt;<code>属性</code>-&gt;<code>高级系统设置</code>-&gt;<code>环境变量</code>-&gt;新建一个叫<code>ARDUINO</code>的系统变量-&gt;值改成你的安装路径:<br><img src="https://img-blog.csdnimg.cn/20200215130034691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>添加第三方开发板，<code>文件</code>-&gt;<code>首选项</code>-&gt;<code>附加开发板</code>：<br><img src="https://img-blog.csdnimg.cn/20200215130438601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  点击图中<a href="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" target="_blank" rel="noopener">红圈链接</a>进入开发板链接网站，然后把相应的链接粘贴到Arduino IDE的白框，每行一个：<br><img src="https://img-blog.csdnimg.cn/20200215130941622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>然后在<code>Arduino IDE里工具</code>-&gt;<code>开发板</code>-&gt;<code>开发板管理</code>：<br><img src="https://img-blog.csdnimg.cn/20200215131152301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  搜索<code>esp8266</code>即可，如果下面进度条迟迟加载不出来（原因你懂的），可以换下网络多试几遍（可能需要任务管理器结束任务），也可以挂代理，会比较快。<br><img src="https://img-blog.csdnimg.cn/2020021513131419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="2-VScode的安装与使用"><a href="#2-VScode的安装与使用" class="headerlink" title="2.VScode的安装与使用"></a>2.VScode的安装与使用</h2><p>  进入<a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">官网</a>下载相应的安装版本,默认安装就行，别忘<strong>勾选添加路径</strong>。然后进入<code>VScode</code>添加一些插件，需要什么插件搜索就行，可以参考下我的：<br><img src="https://img-blog.csdnimg.cn/2020021513215291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  然后做一些设置，主界面-&gt;<code>文件</code>-&gt;<code>首选项</code>-&gt;<code>设置</code>，点击右上角按钮进入<code>settings.json</code>:<br><img src="https://img-blog.csdnimg.cn/20200215132538855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>做如下设置：</p><pre class="line-numbers language-json"><code class="language-json">    <span class="token property">"arduino.path"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files (x86)\\Arduino"</span><span class="token punctuation">,</span>    <span class="token property">"C_Cpp.intelliSenseEngine"</span><span class="token operator">:</span> <span class="token string">"Tag Parser"</span><span class="token punctuation">,</span>    <span class="token property">"editor.insertSpaces"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"files.autoGuessEncoding"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"arduino.logLevel"</span><span class="token operator">:</span> <span class="token string">"info"</span><span class="token punctuation">,</span>    <span class="token property">"explorer.confirmDelete"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"editor.detectIndentation"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200215132839797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  其中<code>Arduino IDE</code>的安装位置根据实际情况改动，<kbd>ctrl</kbd>+<kbd>s</kbd>保存即可。然后文件-&gt;打开文件夹，选中你存放Arduino程序的<strong>文件夹</strong>，注意是文件夹，不是里面的<code>.ino</code>文件。然后点击页面底部相应按钮选择开发板，编译，上传（右上角）即可：<br><img src="https://img-blog.csdnimg.cn/20200215133613970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="3-解决VScode编译Arduino程序速度慢的问题"><a href="#3-解决VScode编译Arduino程序速度慢的问题" class="headerlink" title="3.解决VScode编译Arduino程序速度慢的问题"></a>3.解决VScode编译Arduino程序速度慢的问题</h2><p><img src="https://img-blog.csdnimg.cn/20200215134740202.png" alt=""><br>  编译时可以看到<code>VScode</code>有<code>Warning</code>警告，此时我们只需在当前项目的<code>.vscode</code> -&gt; <code>arduino.json</code>文件中将输出目录 <code>output</code> 配置一下就可以大大提高二次下载的编译速度，<strong>注意json的格式</strong>，什么时候末尾该有逗号。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"board"</span><span class="token operator">:</span> <span class="token string">"esp8266:esp8266:generic"</span><span class="token punctuation">,</span>    <span class="token property">"configuration"</span><span class="token operator">:</span> <span class="token string">"xtal=80,vt=flash,......省略一些"</span><span class="token punctuation">,</span>    <span class="token property">"programmer"</span><span class="token operator">:</span> <span class="token string">"AVR ISP"</span><span class="token punctuation">,</span>    <span class="token property">"output"</span><span class="token operator">:</span> <span class="token string">"./build"</span><span class="token punctuation">,</span>    <span class="token property">"sketch"</span><span class="token operator">:</span> <span class="token string">"Wifi_Scan.ino"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-VScode中的Git使用"><a href="#4-VScode中的Git使用" class="headerlink" title="4.VScode中的Git使用"></a>4.VScode中的Git使用</h2><p>  关于<code>Git</code>的使用和总结可以参考我的<a href="https://sunmengxin.cn/Git-tutorial/">Git教程学习笔记及VScode中Git使用</a>。打开<code>VScode</code>：<code>文件-&gt;首选项-&gt;设置</code>，然后点击图中<code>红圈</code>里的按钮：<br><img src="https://img-blog.csdnimg.cn/20200214213620479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  在设置里添加以下两句，其中第一句添加git安装位置（确保安装git时勾选添加到系统变量），第二局将<code>VScode</code>中的终端换成默认<code>Git Bash</code>。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"git.path"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\Git\\cmd\\git.exe"</span><span class="token punctuation">,</span><span class="token property">"terminal.integrated.shell.windows"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\Git\\bin\\bash.exe"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后用快捷键<kbd>Ctrl</kbd>+<kbd>~</kbd>打开终端输入<code>git init</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> C:/Users/MengXin/Desktop/ESP/ESP8266/code/test_hardwarw/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  然后点击<code>新建文件</code>，输入文件名<code>.gitignore</code>，确定让Git跟踪哪些文件，忽略哪些文件，有关详细用法可参考<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方中文教程</a>。</p><pre><code>    build/    .vscode/*    !.vscode/arduino.json</code></pre><p><img src="https://img-blog.csdnimg.cn/20200215142835115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  输入后<code>ctrl</code>+<code>s</code>保存，然后左侧<code>源代码管理</code>-&gt;右上角三个点<code>更多操作</code>-&gt;<code>暂存所有更改</code>-&gt;<code>全部提交</code>-&gt;<code>输入提交信息</code>，例如我的信息<code>第一次提交代码</code>，然后在终端输入<code>git log</code>即可查看信息；这几步相当于Git命令中的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add <span class="token keyword">.</span>$ <span class="token function">git</span> commit -m <span class="token string">"第一次提交代码"</span>$ <span class="token function">git</span> log  commit 8a636c62040cdc7897f90766636943c6ddc8af19 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>  Author: MM-X <span class="token operator">&lt;</span>smx******@gmail.com<span class="token operator">></span>  Date:   Sat Feb 15 14:37:58 2020 +0800    第一次提交代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200215143104710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br><img src="https://img-blog.csdnimg.cn/20200215143319154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""></p><h2 id="5-Git中文显示乱码问题"><a href="#5-Git中文显示乱码问题" class="headerlink" title="5.Git中文显示乱码问题"></a>5.Git中文显示乱码问题</h2><p>  在桌面空白<code>右击</code>-&gt;<code>Git Bash Here</code>-&gt;<code>在弹出框右击</code>-&gt;<code>Options</code>-&gt;<code>Text</code>，做如下设置即可。<br><img src="https://img-blog.csdnimg.cn/20200215144319996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br><br><br><br><br><strong>参考：</strong><br>  <a href="https://www.arduino.cn/thread-81253-1-1.html" target="_blank" rel="noopener"> ESP32使用blinker库的arduino IDE上手教程,升级vscode教程,git教程</a><br>  <a href="https://sunmengxin.cn/Git-tutorial/">Git教程学习笔记及VScode中Git使用</a><br>  <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的Git教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> VScode </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git教程学习笔记及VScode中Git使用</title>
      <link href="/Git-tutorial/"/>
      <url>/Git-tutorial/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  一直想学git,奈何初学时相关的新名词太多，一直没理解太深，刚好最近有时间把<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰的git教程</a>看了一遍，峰哥的教程写的很通俗易懂有条理就不说了。但细数起来，git的命令还是有点多的，就在学的同时记了些笔记分享一下。<br>  对于新手，非常建议学习git之前，先把GitHub玩一遍，这里也推荐一个GitHub学习相关的网站，写的也很通俗易懂——<a href="https://gitbeijing.com/" target="_blank" rel="noopener">Git北京</a>。</p><h2 id="1-配置git"><a href="#1-配置git" class="headerlink" title="1.配置git"></a>1.配置git</h2><pre><code>$ git config --global user.name "Your Name"  配置git全局用户名$ git config --global user.email "email@example.com"  配置git全局邮箱$ git config --global credential.helper store  保存登录密码</code></pre><h2 id="2-创建版本库"><a href="#2-创建版本库" class="headerlink" title="2.创建版本库"></a>2.创建版本库</h2><pre><code>$ mkdir learngit$ cd learngit$ pwd$ git init$ git add readme.txt$ git add readme.txt</code></pre><h2 id="3-版本回退"><a href="#3-版本回退" class="headerlink" title="3.版本回退"></a>3.版本回退</h2><pre><code>$ git status$ git diff readme.txt$ git log （--pretty=oneline）$ git reset --hard HEAD^$ git reflog 记录git的每次命令</code></pre><h2 id="4-工作区和暂存区"><a href="#4-工作区和暂存区" class="headerlink" title="4.工作区和暂存区"></a>4.工作区和暂存区</h2><pre><code>Git管理的文件分为：工作区，版本库；版本库又分为暂存区stage和暂存区分支master(仓库)工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库git add把文件从工作区&gt;&gt;&gt;&gt;暂存区；git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，git diff查看工作区和暂存区差异，git diff HEAD -- filename 查看暂存区和仓库差异，git diff HEAD 查看工作区和仓库的差异，git checkout类似git add反向命令，指对工作区的操作git reset HEAD类似git commit反向命令，指对缓存区的操作$ git diff HEAD -- readme.txt $ git reset HEAD readme.txt  缓存区的修改撤销放回工作区$ git checkout -- readme.txt  丢弃工作区的修改</code></pre><h2 id="5-添加远程仓库"><a href="#5-添加远程仓库" class="headerlink" title="5.添加远程仓库"></a>5.添加远程仓库</h2><pre><code>$ ssh-keygen -t rsa -C "youremail@example.com"$ git remote add origin git@github.com:michaelliao/learngit.git$ git push -u origin master  加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来$ git push origin master$ git clone git@github.com:michaelliao/gitskills.git</code></pre><h2 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6.分支管理"></a>6.分支管理</h2><pre><code>$ git checkout -b dev$ git branch dev  创建分支$ git checkout dev$ git branch 查看当前分支$ git checkout master$ git merge dev$ git branch -d dev 删除&amp; git branch -D &lt;name&gt;强行删除。$ git branch$ git switch -c dev$ git switch master$ git merge --abort  有冲突时放弃merge$ git log --graph --pretty=oneline --abbrev-commit   按行显示 缩写强制禁用fast forward,防止删除分支后丢掉分支部分$ git merge --no-ff -m "merge with no-ff" dev</code></pre><h3 id="6-1、处理bug分支"><a href="#6-1、处理bug分支" class="headerlink" title="6.1、处理bug分支"></a>6.1、处理bug分支</h3><pre><code>    $ git stash  压入存储区    $ git stash list 查看存储区    $ git stash apply &amp;&amp; $ git stash drop 恢复删除临时区    $ git stash pop  同上    $ git cherry-pick 4c805e2  将master的修改操作复制到当前分支    $ git stash apply stash@{0}</code></pre><h3 id="6-2、多人协作"><a href="#6-2、多人协作" class="headerlink" title="6.2、多人协作"></a>6.2、多人协作</h3><pre><code>    $ git remote 查看远程仓库名称    $ git remote -v  查看远程仓库信息    $ git push origin master  推送master分支    $ git push origin dev  推送dev分支    $ git clone git@github.com:michaelliao/learngit.git  抓取分支    $ git checkout -b dev origin/dev  创建远程origin的dev分支到本低    $ git pull 把最新的提交从origin/dev抓下来    $ git branch --set-upstream-to=origin/dev dev  设置dev和origin/dev的链接：    $ git commit -m "fix env conflict"    $ git push origin dev    $ git rebase  原本分叉的提交现在变成一条直线</code></pre><h2 id="7-标签管理"><a href="#7-标签管理" class="headerlink" title="7.标签管理"></a>7.标签管理</h2><pre><code>$ git tag v1.0  给当前版本打标签$ git tag 显示已有标签$ git log --pretty=oneline --abbrev-commit$ git tag v0.9 f52c633 对历史节点打标签$ git show v0.9 显示版本信息$ git tag -a v0.1 -m "version 0.1 released" 1094adb  带说明的标签$ git tag -d v0.1 删除标签$ git push origin v1.0  推送某个标签到远程$ git push origin --tags  一次性推送全部尚未推送到远程的本地标签$ git tag -d v0.9 &gt;&gt; $ git push origin :refs/tags/v0.9  删除远程标签  $ git push origin --delete  tagname</code></pre><h2 id="8-自定义git"><a href="#8-自定义git" class="headerlink" title="8.自定义git"></a>8.自定义git</h2><pre><code>$ git config --global color.ui true   Git显示颜色忽略文件 .gitignore 文件 https://github.com/github/gitignore$ git add -f App.class 强制添加$ git check-ignore -v App.class$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch$ git config --global alias.last 'log -1'  用git last就能显示最近一次的提交git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"每个仓库的Git配置文件都放在.git/config文件中</code></pre><h2 id="9-VScode中的Git使用"><a href="#9-VScode中的Git使用" class="headerlink" title="9.VScode中的Git使用"></a>9.VScode中的Git使用</h2><p>  VScode的安装这里就不多说了，打开VScode：<code>文件-&gt;首选项-&gt;设置</code>，然后点击图中<code>红圈</code>里的按钮：<br><img src="https://img-blog.csdnimg.cn/20200214213620479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxX181OTA5ODA=,size_16,color_FFFFFF,t_70" alt=""><br>  在设置里添加以下两句，其中第一句添加git安装位置（确保安装git时勾选添加到系统变量），第二局将VScode中的终端换成默认<code>Git Bash</code>。</p><pre class="line-numbers language-json"><code class="language-json"><span class="token property">"git.path"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\Git\\cmd\\git.exe"</span><span class="token punctuation">,</span><span class="token property">"terminal.integrated.shell.windows"</span><span class="token operator">:</span> <span class="token string">"C:\\Program Files\\Git\\bin\\bash.exe"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  然后用VScode打开练习Git的文件夹，<kbd>Ctrl</kbd>+<kbd>~</kbd>打开终端输入<code>git status</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> status On branch masterYour branch is up to <span class="token function">date</span> with <span class="token string">'origin/master'</span><span class="token keyword">.</span>Changes not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   <span class="token string">"git\346\200\273\347\273\223.txt"</span>no changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Git </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown教程</title>
      <link href="/markdown-tutorial/"/>
      <url>/markdown-tutorial/</url>
      
        <content type="html"><![CDATA[<h2 id="一-标题"><a href="#一-标题" class="headerlink" title="一. 标题"></a>一. 标题</h2><p><span id="jump"> </span></p><blockquote><p>一级标题<br>======  </p><p>二级标题<br>-—-  </p></blockquote><p><strong>显示效果：</strong><br><img src="https://s2.ax1x.com/2020/02/14/1XLRWq.png" alt=""> </p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题 </p></blockquote><p><strong>显示效果：</strong><br><img src="https://s2.ax1x.com/2020/02/14/1XOI3t.png" alt=""><br><strong>HTML格式：</strong>  </p><blockquote><p>&lt;h1&gt;这是一级标题&lt;/h1&gt;<br>&lt;h2&gt;这是二级标题&lt;/h2&gt;<br>&lt;h3&gt;这是三级标题&lt;/h3&gt;</p></blockquote><hr><h2 id="二-段落"><a href="#二-段落" class="headerlink" title="二. 段落"></a>二. 段落</h2><h3 id="1-换行"><a href="#1-换行" class="headerlink" title="1. 换行"></a>1. 换行</h3><blockquote><p>1.段落换行使用两个以上空格+回车;<br>2.或者中间一个空行表示换行;<br>3.使用<code>&lt;br&gt;</code>换行，适用于插入多行空行； </p></blockquote><p><strong>显示效果：</strong><br>第一句<br><br><br>隔两行第二句</p><h3 id="2-缩进字符"><a href="#2-缩进字符" class="headerlink" title="2. 缩进字符"></a>2. 缩进字符</h3><blockquote><p><code>&amp;nbsp;</code>或者<code>&amp;#160;</code>：缩进1/4中文,别忘了写分号；<br><code>&amp;ensp;</code>或者<code>&amp;#8194;</code>：缩进1/2中文或者1个字符；<br><code>&amp;emsp;</code>或者<code>&amp;#8195;</code>：缩进1中文或者2个字符，建议用这个；</p></blockquote><p><strong>显示效果：</strong><br>不缩进的句子<br>&nbsp;用它缩进的句子<code>&amp;nbsp;</code><br>不缩进的句子<br> 用它缩进的句子<code>&amp;ensp;</code><br>不缩进的句子<br> 用它缩进的句子<code>&amp;emsp;</code>   </p><h3 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h3><blockquote><p>*斜体文本*<br>_斜体文本_<br>**粗体文本**<br>__粗体文本__<br>***粗斜体文本***<br>___粗斜体文本___</p></blockquote><p><strong>显示效果：</strong><br><img src="https://s2.ax1x.com/2020/02/14/1XjqYj.png" alt=""></p><h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4. 分割线"></a>4. 分割线</h3><blockquote><p>***<br>******<br>_ _ _<br>- - -<br>-————</p></blockquote><p><strong>显示效果：</strong></p><hr><hr><hr><hr><hr><hr><h3 id="5-删除线"><a href="#5-删除线" class="headerlink" title="5. 删除线"></a>5. 删除线</h3><blockquote><p>~~删除此段~~</p></blockquote><p><strong>显示效果:</strong><br><del>删除此段</del></p><h3 id="6-下划线"><a href="#6-下划线" class="headerlink" title="6. 下划线"></a>6. 下划线</h3><blockquote><p>&lt;u&gt;引用自HTML&lt;/u&gt;</p></blockquote><p><strong>显示效果：</strong><br><u>引用自HTML</u></p><h3 id="7-脚注"><a href="#7-脚注" class="headerlink" title="7. 脚注"></a>7. 脚注</h3><blockquote><p>参考文献1[1]，参考文献2[2]。<br>[1]:参考文献1<br>[2]:参考文献2</p></blockquote><p>参考文献1<a href="https://sunmengxin.cn">1</a>，参考文献2<a href="https://sunmengxin.cn">2</a>。</p><hr><h2 id="三-列表"><a href="#三-列表" class="headerlink" title="三. 列表"></a>三. 列表</h2><h3 id="1-无顺序"><a href="#1-无顺序" class="headerlink" title="1. 无顺序"></a>1. 无顺序</h3><blockquote><p>* 第一项<br>* 第二项<br>* 第三项</p></blockquote><ul><li>第一项</li><li>第二项</li><li>第三项  </li></ul><blockquote><p>+ 第一项<br>+ 第二项</p></blockquote><ul><li>第一项</li><li>第二项  </li></ul><blockquote><p>- 第一项<br>- 第二项</p></blockquote><ul><li>第一项</li><li>第二项</li></ul><h3 id="2-有顺序"><a href="#2-有顺序" class="headerlink" title="2. 有顺序"></a>2. 有顺序</h3><blockquote><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol></blockquote><ol><li>第一点</li><li>第二点</li><li>第三点</li></ol><h3 id="3-列表嵌套"><a href="#3-列表嵌套" class="headerlink" title="3. 列表嵌套"></a>3. 列表嵌套</h3><blockquote><ol><li>第一项<br> - 第一点<br> - 第二点</li><li>第二项<br> - 第一点<br> - 第二点</li></ol></blockquote><ol><li>第一项<ul><li>第一点</li><li>第二点</li></ul></li><li>第二项<ul><li>第一点</li><li>第二点</li></ul></li></ol><hr><h2 id="四-区块"><a href="#四-区块" class="headerlink" title="四. 区块"></a>四. 区块</h2><p>&gt; 区块引用<br>&gt; 区块<br>区块<br>区块</p><blockquote><p>区块引用<br>区块<br>区块<br>区块</p></blockquote><h3 id="1-区块嵌套"><a href="#1-区块嵌套" class="headerlink" title="1. 区块嵌套"></a>1. 区块嵌套</h3><p>&gt; 最外层<br>&gt;&gt; 次外层<br>&gt;&gt;&gt; 里层</p><blockquote><p>最外层</p><blockquote><p>次外层</p><blockquote><p>里层<br><br></p></blockquote></blockquote></blockquote><h3 id="2-区块中使用列表"><a href="#2-区块中使用列表" class="headerlink" title="2. 区块中使用列表"></a>2. 区块中使用列表</h3><p>&gt; 区块使用列表<br>&gt; 1. 第一点<br>&gt; 2. 第二点<br>&gt; - 第一项<br>&gt; - 第二项</p><blockquote><p>区块使用列表</p><ol><li>第一点</li><li>第二点</li></ol><ul><li>第一项</li><li>第二项</li></ul></blockquote><h3 id="3-列表中使用区块"><a href="#3-列表中使用区块" class="headerlink" title="3. 列表中使用区块"></a>3. 列表中使用区块</h3><ul><li>第一项<blockquote><p>区块<br>区块2</p></blockquote></li><li>第二项<blockquote><p>区块1<br>区块2  </p></blockquote></li></ul><blockquote><p>HTML: &lt;blockquote&gt;引用的内容&lt;/blockquote&gt;</p></blockquote><h2 id="五-代码"><a href="#五-代码" class="headerlink" title="五. 代码"></a>五. 代码</h2><p>代码区块使用4个空格或者一个制表符 </p><pre><code>for(i=0,i&lt;2020,i++){    year += year;}</code></pre><p>代码高亮,用```指定语言,<strong>注意不是单引号，是键盘上的<kbd>~</kbd>键</strong></p><blockquote><p>```c<br>for(i=0,i&lt;2020,i++)<br>    {<br>        year += year;<br>    }<br>```</p></blockquote><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token operator">&lt;</span><span class="token number">2020</span><span class="token punctuation">,</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        year <span class="token operator">+</span><span class="token operator">=</span> year<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>单个代码`a=1` </p></blockquote><p>单个代码<code>a=1</code> </p><h2 id="六-链接"><a href="#六-链接" class="headerlink" title="六. 链接"></a>六. 链接</h2><blockquote><p>这是一个链接[我的博客](<a href="https://sunmengxin.cn\">https://sunmengxin.cn\</a>)<br>直接使用链接 &lt;<a href="http://www.sunmengxin.cn\>" target="_blank" rel="noopener">www.sunmengxin.cn\&gt;</a></p></blockquote><p>这是一个链接<a href="https://sunmengxin.cn">我的博客</a><br>直接使用链接 &lt;<a href="http://www.sunmengxin.cn>" target="_blank" rel="noopener">www.sunmengxin.cn&gt;</a></p><h3 id="1-高级链接"><a href="#1-高级链接" class="headerlink" title="1. 高级链接"></a>1. 高级链接</h3><p>链接用变量替代,并在文章末尾加变量</p><blockquote><p>用’x’代替网址[Google][x]<br>变量用中括号括起来[BLOG][blog]</p><p>[x]: <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a><br>[blog]: <a href="https://sunmengxin.cn">https://sunmengxin.cn</a></p></blockquote><p>用’x’代替网址 <a href="www.google.com">Google</a><br>变量用中括号括起来 <a href="https://sunmengxin.cn">BLOG</a> </p><blockquote><p>HTML &lt;a href=”超链接地址” title=”超链接title”&gt;超链接显示名&lt;/a&gt;</p></blockquote><h2 id="七-图片"><a href="#七-图片" class="headerlink" title="七. 图片"></a>七. 图片</h2><blockquote><p>![alt 属性文本替代文字] （ 图片地址， “可选标题” ）</p></blockquote><p><a href="logo"><img src="https://s2.ax1x.com/2020/02/13/1q4zjI.jpg" alt="头像"></a></p><p>网址使用变量  </p><blockquote><p>![头像][img]<br><br><br>[img]: <a href="https://sunmengxin.cn">https://sunmengxin.cn</a></p></blockquote><p>用HTML格式：  </p><blockquote><p>&lt;img src=”图片链接” alt=”图片alt” title=”图片title”&gt;  </p></blockquote><h2 id="八-表格"><a href="#八-表格" class="headerlink" title="八. 表格"></a>八. 表格</h2><blockquote><p>|  表头   | 表头  |<br>|  —-  | —-  |<br>| 单元格  | 单元格 |<br>| 单元格  | 单元格 |</p></blockquote><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><blockquote><p>| 左对齐 | 右对齐 | 居中对齐 |<br>| :—–| —-: | :—-: |<br>| 单元格 | 单元格 | 单元格 |<br>| 单元格 | 单元格 | 单元格 | </p></blockquote><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><p>任务列表  </p><blockquote><p>- [x] 洗碗<br>- [ ] 清洗油烟机<br>- [ ] 拖地</p></blockquote><ul><li><input checked="" disabled="" type="checkbox"> 洗碗</li><li><input disabled="" type="checkbox"> 清洗油烟机</li><li><input disabled="" type="checkbox"> 拖地</li></ul><h2 id="九-高级技巧"><a href="#九-高级技巧" class="headerlink" title="九. 高级技巧"></a>九. 高级技巧</h2><blockquote><p>目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 </p></blockquote><blockquote><p>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 </p></blockquote><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑  </p><p>反斜杠转义</p><blockquote><p>  \   反斜线<br>    `   反引号<br>    *   星号<br>    _   下划线<br>    {}  花括号<br>    []  方括号<br>    ()  小括号<br>    #   井字号<br>    +   加号<br>    -   减号<br>    .   英文句点<br>    !   感叹号</p></blockquote><h3 id="1-公式"><a href="#1-公式" class="headerlink" title="1. 公式"></a>1. 公式</h3><p><img src="https://s2.ax1x.com/2020/02/14/1jyIHS.png" alt=""></p><p>$${^i_{i-1}}T = Rot(x_{i-1}, \alpha_{i-1}) \cdot Trans(x_{i-1},a_i) \cdot Rot(z_i, \theta_i) \cdot Trans(z_i, d_i)$$</p><p>行内公式：<br>两边仅保留一个美元符号$a=1$。</p><h3 id="2-内嵌图标"><a href="#2-内嵌图标" class="headerlink" title="2. 内嵌图标"></a>2. 内嵌图标</h3><p><i class="icon-file"></i>  新建文档  </p><p><a href="https://github.com/MM-X" target="_blank" rel="noopener"><i class="fab fa-github"></i></a> 点击图标进入GitHub<br><i class="fas fa-blog"></i><br>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站</p><h3 id="3-emoji表情"><a href="#3-emoji表情" class="headerlink" title="3. emoji表情"></a>3. emoji表情</h3><p>使用格式<code>:emoji:</code>的格式，详细列表可参考：<br><a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webpagefx.com/tools/emoji-cheat-sheet/</a></p><blockquote><dl><dt>: smile :<br>: kissing_hear :</dt><dd>beer :</dd></dl></blockquote><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span><br><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f618.png?v8">😘</span><br><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f37a.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f37a.png?v8">🍺</span>  </p><h3 id="4-背景色"><a href="#4-背景色" class="headerlink" title="4. 背景色"></a>4. 背景色</h3><blockquote><p>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=Green&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</p></blockquote><table><tbody><tr><td bgcolor="Green">背景色是：Green</td></tr></tbody></table><h3 id="5-锚点"><a href="#5-锚点" class="headerlink" title="5. 锚点"></a>5. 锚点</h3><p>相当于同一篇文章里的超级链接</p><blockquote><p>1.定义一个锚(id)：<table><tbody><tr><td bgcolor="YellowGreen">&lt;span id=”jump”&gt;跳转到的地方&lt;/span&gt;</td></tr></tbody></table><br>2.使用markdown语法：[点击跳转]（#jump）</p></blockquote><p>跳转到<a href="#jump">开头</a></p><br><br><p><strong>注：</strong>在线Markdown编辑器<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">https://www.zybuluo.com/mdeditor</a></p><br><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 原创 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人学习之路</title>
      <link href="/how-to-learn-robotics/SUMMARY/"/>
      <url>/how-to-learn-robotics/SUMMARY/</url>
      
        <content type="html"><![CDATA[<p>&nbsp; &nbsp; &nbsp; &nbsp;记得2015年刚读本科时，机械专业还是就业前景很不错的专业，但随着这些年各种人工智能的发展，机械专业逐渐成了劝退专业<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f60f.png?v8">😏</span>。记得大四时看到一片关于知乎上YY硕写的一篇<a href="https://zhuanlan.zhihu.com/p/22266788" target="_blank" rel="noopener">机器人工程师学习计划</a>,看的自己激动不已，但是又惋惜有点相见恨晚，浪费了几年也没学到什么东西。可能确实是眼界问题，没有接触到那么多东西所以也不了解，以至于自己成了固步自封的井底之蛙<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f438.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f438.png?v8">🐸</span>。既然工科学到最后都是学数学，那也就没什么学科差别了吧<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f914.png?v8">🤔</span>。<br>&nbsp; &nbsp; &nbsp; &nbsp;暑假开学后，经<a href="https://www.zhihu.com/people/he-yi-59-59/activities" target="_blank" rel="noopener">师兄</a>推荐发现了下面这篇机器人学习之路，感觉受益良多，所以转载一下。这篇文章是GitHub上的一个开源项目<a href="https://github.com/qqfly/how-to-learn-robotics" target="_blank" rel="noopener">How to Learn Robotics</a>,获得了不少star。这里先转载一下，后面准备把<a href="https://zhuanlan.zhihu.com/p/22266788" target="_blank" rel="noopener">机器人工程师学习计划</a>和<a href="https://qiu6401.gitbook.io/how-to-learn-robotics" target="_blank" rel="noopener">How to Learn Robotics</a>然后再加上自己微少的经验整合一下<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span>。</p><p><strong>以下为转载部分：</strong><br><strong>本篇文章转自</strong>： <a href="https://qiu6401.gitbook.io/how-to-learn-robotics" target="_blank" rel="noopener">How to Learn Robotics</a>  </p><hr><hr><h2 id="一-前言-（Preface）"><a href="#一-前言-（Preface）" class="headerlink" title="一. 前言 （Preface）"></a>一. 前言 （Preface）</h2><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;<strong><a href="http://www.rvbust.com" target="_blank" rel="noopener">RVBUST INC.</a></strong> 成立半年有余。面试过不少从事机器人研究的小伙伴后，我发现一个问题：<strong>绝大多数大陆毕业的学生都不像是「科班出身」的</strong>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，如果仅从工作教育经历上看 —— 大部分毕业于机电、计算机专业，甚至是研究机器人的实验室，有过机器人公司的工作经历 —— 这些人应该都算是「专业选手」。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，从面试情况上看，绝大多数人都不具备机器人学的完整知识体系：画电路板的小伙伴不知道怎么进行机器人工作空间分析；设计机构的小伙伴不知道怎么把动力学用在控制上；做控制算法的小伙伴不知道什么的构型空间（Configuration Space）；做运动规划的小伙伴不知道什么是Q-learning；做深度强化学习的小伙伴不知道学习到的控制指令要怎么让实际机器人运动起来。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从我这几年的学习经历上看，我是能理解这一现象的。博士刚入学的时候，我接下了师兄的 SmartPal 机器人。靠着师兄的「祖传代码」，也曾狐假虎威地在外宾面前做过一些演示：</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNF9c4.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，当我后来真正开始看这些「祖传代码」的时候，我发现实际发给机器人的只有几个关节<strong>位置</strong>点而已。</p><p><strong>「PID 在哪里？？？」</strong></p><p>&nbsp; &nbsp; &nbsp; &nbsp;这是我当时产生的最大疑问。这个代码逻辑跟我本科玩的四旋翼、智能车等都完全不一样！</p><p>&nbsp; &nbsp; &nbsp; &nbsp;于是，拿着这个疑问，我在实验室问了一圈，没有得到答案。即使后来，我选修了好几门跟机器人相关的研究生课程。经过一年的学习，我还是没有得到答案。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;是的，作为国内最早开展机器人研究的院校之一，这里的机器人研究生课程只教我们如何建立 DH 坐标系，动力学只是简单计算了一个平面三连杆。根本没有涉及控制、轨迹规划的内容，甚至连运动学逆解也没有要求大家计算。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;据我所知，很多其他研究机构也是如此。国内机器人学这块还没有形成完整的教学体系，所以，大陆毕业的学生基本上都没有接受过完整的机器人学系统教育，只有在做项目的时候通过自学掌握项目所需的内容。这也就造就了一大批没有算过机器人运动学逆解的机器人专业博硕士生。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，并不是说「运动学逆解」、「轨迹插补」之类的知识有多难。我想强调的是，在大陆，一个学生只通过上课，无法掌握、甚至是无法接触到这些机器人学中非常基础的知识。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，这一情况在大陆比较普遍，而对于国外或者港台高校毕业的学生，基本上都没有这个问题。国外或者港台高校在机器人学这块的教学体系相对比较完整，基本上大作业都会覆盖主要的知识点，并且大都要求编程实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;虽然，大多数小伙伴都是「非科班出身」的，但是，根据我的经验，大陆的学生还是非常聪明的，基本只要得到一些简单的正确引导，就能很快通过自学掌握这些知识。所以，我们不妨来看看「非科班出身」如何学习机器人学吧。</p><hr><h2 id="二-先修知识（Prerequisite）"><a href="#二-先修知识（Prerequisite）" class="headerlink" title="二. 先修知识（Prerequisite）"></a>二. 先修知识（Prerequisite）</h2><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，先修知识会随着研究的深入而变化，尤其是数学，数学就像是写轮眼，看同一个石碑，不同层次的「写轮眼」所看到的内容也完全不同。</p><p align="center">  <img width="800" src="https://s2.ax1x.com/2020/01/02/lNivNV.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;只会加减乘除，可以从事机器人调试工程师；学了线性代数、微积分，就可以掌握运动学、动力学建模等基础内容；学了计算方法、凸优化、微分几何就可以参与一些辨识、规划、学习方面的工作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，由于机器人学涉及面广，不同方向所需要的基础知识也完全不同，如果一开始就陷入「先修知识」的泥潭中，可能就得不偿失了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;所以，我认为，可以先列一些比较基础的先修知识，其他的在后续相应部分提及即可：</p><ol><li><p><strong>基本的英文</strong>：在机器人方面，目前基本上没有非常合适的中文教材可以推荐。写得深入浅出的教材大都是国外的，大家<strong>必须</strong>学会阅读英文教材。这个过程一开始肯定是痛苦的，但是，基本上坚持一个月就会习惯了。</p></li><li><p><strong>学会使用 VPN</strong>。原因同上，基本上有用的资料都需要通过 Goolge 或 Youtube 获取。</p></li><li><p><strong>线性代数</strong>：所有的空间变换、机器人相关计算都依赖于线性代数，甚至需要有一些基本的「线性空间」思维。对于线性代数，我首推 Prof. Gilbert Strang 的《Linear Algebra》，在 <a href="https://www.youtube.com/watch?v=hNDFwVVKVk0&amp;list=PL221E2BBF13BECF6C" target="_blank" rel="noopener">Youtube</a> 和<a href="http://open.163.com/special/opencourse/daishu.html" target="_blank" rel="noopener">网易公开课</a>上可以找到视频。这门课一开始就引导大家从空间的角度看待问题，而不只强调如何计算。而且，网易公开课上有中文字幕，对于初学者也还算友好。</p></li><li><p><strong>微积分</strong>：机器人里，所有涉及到导数、积分、优化的地方，都需要用到微积分。所以，这门数学课也是一开始就绕不开的。我没有太好的视频推荐，不妨也看看 Gilbert Strange 的<a href="http://open.163.com/special/opencourse/weijifen.html" target="_blank" rel="noopener">《微积分重点》</a> (<a href="https://ocw.mit.edu/resources/res-18-005-highlights-of-calculus-spring-2010/" target="_blank" rel="noopener">Highlights of Calculus</a>)？</p></li><li><p><strong>理论力学</strong>：机器人学就是每天与力打交道。但是一般机器人教材里都不会仔细推导空间变换、虚功原理、拉格朗日等力学理论，而且这些东西又相对抽象，很多初学者的自学过程就是被截杀在动力学章节的。当然，这部分我也没有太好的推荐资料，学堂在线上有清华高云峰老师的<a href="https://www.xuetangx.com/courses/TsinghuaX/20330334X/_/about" target="_blank" rel="noopener">《理论力学》</a>公开课，也可以参考一下。（但至少我当年上他的课总是犯困）。</p><!-- TODO: Improve <!theoretical mechanics>>  --></li><li><p><strong>Matlab or Python</strong>：这两个都是非常容易上手，且非常方便数据可视化的编程语言。大家在学习机器人学的过程中，能非常容易地通过这类脚本语言实现一些算法，从而用于验证自己的推导结果。当然，这两部分只要掌握基本的矩阵操作和可视化操作就可以了。其他更高级的用法可以之后再学习。Coursera 上很容易找到这两门语言的入门课程 <a href="https://www.coursera.org/learn/matlab" target="_blank" rel="noopener">Matlab</a>、<a href="https://www.coursera.org/specializations/python" target="_blank" rel="noopener">Python</a>。</p></li><li><p><strong>控制理论</strong>：机器人学是离不开控制的，但是机器人学教材一般不会过多介绍这块。当然，目前大多数工业机器人都还是使用比较简单的算法。但是，作为研究者，有必要了解一些基本的控制理论，例如 PID、状态方程、可观性、可控性、李雅普诺夫、最优控制、一点点非线性控制与一点点智能控制等。这部分可以在 Youtube 上看看 <a href="www.youtube.com/channel/UCq0imsn84ShAe9PBOFnoIrg">Brian Douglas</a> 的视频。</p></li></ol><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiW7t.jpg"></p><ol><li><p><strong>数字电路与模拟电路</strong>：机器人是一门实践科学，只有当你把你推导的公式写成代码、并最终让实际机器人按照你的想法动起来的时候，才说明你掌握了相关知识。数电模电的知识可以让你对逻辑电路有个基本了解，不至于后面连为什么电机前面要加一个驱动器都不知道；同时，在身边没有实际机器人的情况下，自己搭个小电路做一些控制实验也是非常方便的。这块知识可以随便找本教材看看，例如我当时用的是唐庆玉老师的教材。</p></li><li><p><strong>一点点单片机</strong>：要想搭建简单的控制电路，只有数电模电知识是不够的，还要能将这些知识转换成实际的电路，并且能运行控制代码，那么就需要会单片机。对于单片机，可以网上随便买一些带伺服电机控制教程的最小系统板，学学 Arduino 或 STM32，当然，如果能参加个 RoboMaster 或者飞思卡尔智能车大赛什么的是最好了，可以对嵌入式的各个模块有个基本了解。</p></li><li><p><strong>Linux 和 C 语言</strong>：现在有了电路部分，我们需要将公式代码变成电路指令，这就涉及嵌入式的编程了。这块建议学一点 C 语言。嵌入式对 C 的要求其实并不高，随便学点语法就够了，例如<a href="https://akaedu.github.io/book/pt01.html" target="_blank" rel="noopener">《C语言入门》</a>。但是，如果未来想做一些更加上层的工作，最好一开始就把 C 学好。学编程，Linux 是个不错的选择，所以，这时候，可以尝试安装个 Linux 系统，在上面学习 C 语言。</p></li><li><p><strong>基本的3D设计</strong>：在制作实验平台的时候，经常会遇到需要加工设计小零件的情况，这时候掌握一个3D设计软件可以大大提高开发速度，例如 SolidWorks 就是个不错的选择。配合上 3D 打印机之类的工具就可以实现快速原型设计了。（即使没有 3D 打印机，在网上也可以很容易找到 3D 打印服务，把你设计的 3D 文件发过去就可以了）。</p></li></ol><p>&nbsp; &nbsp; &nbsp; &nbsp;上面这些知识，基本是一个自动化专业或者机电专业大三学生应该达到的水平。如果对上述几部分有了基本了解，就可以开始看机器人学的知识了。</p><hr><hr><h2 id="三-入门-（GettingStarted）"><a href="#三-入门-（GettingStarted）" class="headerlink" title="三. 入门  （GettingStarted）"></a>三. 入门  （GettingStarted）</h2><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;对于入门部分，实际上就是了解如何让一个工业机器人动起来。这方面其实已经研究非常成熟了，大家看上个世纪的教材就行，个人推荐的是 John Craig 的教材 《Introduction to Robotics: Mechanics and Control》<sup>[1]</sup>，在 <a href="https://www.youtube.com/watch?v=0yD3uBshJB0&amp;list=PL64324A3B147B5578" target="_blank" rel="noopener">Youtube</a> 和<a href="http://open.163.com/special/opencourse/robotics.html" target="_blank" rel="noopener">网易公开课</a>都可以找到斯坦福 Oussama Khatib 大神的视频，基本与 Craig 的教材内容相匹配。</p><p align="center">  <img width="300" src="https://s2.ax1x.com/2020/01/02/lNiDfO.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;建议从 Craig 的教材开始就看英文版本，Google 一下，很容易找到 PDF 版本。作为一本入门教材，Craig 的教材是相当深入浅出的，配合着 Khatib 的视频，可以快速掌握机器人学的基础。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;我常对刚入学的师弟们说，「如果你把这本书的内容掌握了，就已经超过实验室绝大多数师兄师姐了。」</p><p>&nbsp; &nbsp; &nbsp; &nbsp;然而，真正把教材啃下来的并不多。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;所以，我在这里要换个说法了，「如果你把这本书的内容掌握了，就可以胜任国内绝大多数机器人公司的开发工作了。」</p><p>&nbsp; &nbsp; &nbsp; &nbsp;这里，我会大概把基础的知识列一下，时间有限，暂时不会过多展开。顺序可能不完全与 Craig 教材相同。</p><h3 id="3-1-空间变换"><a href="#3-1-空间变换" class="headerlink" title="3.1 空间变换"></a>3.1 空间变换</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;对于这部分内容，如果理论力学学得好的小伙伴，基本是没有太大问题的。问题是，有些小伙伴没有学好。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，其中齐次变换什么的是机器人学中非常基础和重要的内容。其中需要注意的地方有：</p><ul><li><p>熟悉坐标表示方式：坐标系 {B} 在坐标系 {A} 下的位姿为 $${^A_B}T$$ 等；</p></li><li><p>左乘与右乘矩阵的区别；</p></li><li><p>了解旋转矩阵每一列的含义，学会如何通过「目测」写出两个坐标系之间的旋转矩阵；</p></li><li><p>姿态的表示方式：RPY 角、各种欧拉角、轴角（Angle-Axis）表示、旋转矩阵，除了书上的内容，可以顺便看看四元数（Quaternion）表示,了解欧拉角的 Gimbal lock （知道三参数表示的问题，才能更容易接受四元数这样的新事物）；</p></li><li><p>如果有可能，试着了解一下角速度。</p></li></ul><h3 id="3-2-运动学"><a href="#3-2-运动学" class="headerlink" title="3.2 运动学"></a>3.2 运动学</h3><p align="center">  <img width="600" src="https://s2.ax1x.com/2020/01/02/lNijA0.png"></p><p>对于机器人来说，一个基本工作就是计算运动学：</p><ul><li>正运动学：根据关节角度，计算机器人工具坐标系（末端）在机器人基座坐标系（底座）下的位姿；</li><li>逆运动学：给定一个末端位姿，计算达到这个位姿的关节角度。</li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;前面，你知道了可以用一个 4x4 矩阵来描述两个坐标系之间的关系。对于机器人正运动学，如果我们知道每个连杆两两之间的坐标变换，就可以通过矩阵乘法计算出最后的末端位姿了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;为了方便计算两个连杆之间的相对位姿，你就需要学习一个叫做 DH 的建模方法，简而言之，就是按照一定规则建立每个关节坐标系，然后每个坐标系可以用四个参数（DH参数）来确定。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，你网上一搜，就会发现 DH 也有好几种，什么 Standard DH， Modified DH 之类的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;这不重要，你只要知道它是帮你确定两个连杆之间的相对关系就行。不妨掌握 Craig 书上的那种就行（Wikipedia上称为 Modified DH)：</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNi7cQ.png"></p><p>1）建立坐标系：</p><ul><li><p>$z_i$ 轴与第 $i$ 个关节重合，关节转动方向遵照右手定律；</p></li><li><p>$x_i$ 平行于 $z_i$ 和 $z_{i+1}$ 的公垂线：$x_i = z_i \times z_{i+1}$。如果两 $$z$$ 轴平行，则让 $x_i$ 从 $z_{i}$ 指向 $z_{i+1}$；</p></li><li><p>有了 $x$、 $z$ 轴后，就可以用右手定律定义 $y$ 轴方向。</p></li><li><p>除了与每个关节固连的坐标系外，还有可能额外在机器人基座 {B} 与末端工具 {E} 上固连两个坐标系。</p></li></ul><p>2）计算 DH 参数:</p><ul><li><p>$a_i$ 是沿着 $x_i$，从 $z_i$ 到 $z_{i+1}$ 的距离；</p></li><li><p>$\alpha_i$ 是绕着 $x_i$，从 $z_i$ 到 $z_{i+1}$ 的角度；</p></li><li><p>$d_i$ 是沿着 $z_i$，从 $x_{i-1}$ 到 $x_i$ 的距离；</p></li><li><p>$\theta_i$ 是绕着 $z_i$，从 $x_{i-1}$ 到 $x_i$ 的角度。</p></li></ul><p>3）计算变换矩阵：</p><p>$${^i_{i-1}}T = Rot(x_{i-1}, \alpha_{i-1}) \cdot Trans(x_{i-1},a_i) \cdot Rot(z_i, \theta_i) \cdot Trans(z_i, d_i)$$</p><p>$${^i_{i-1}}T=<br>\begin{bmatrix}cos(\theta_i)&amp;-sin(\theta_i)&amp;0&amp;a_{i-1}\\<br>sin(\theta_i)cos(\alpha_{i-1})&amp;cos(\theta_i)cos(\alpha_{i-1})&amp;-sin(\alpha_{i-1})&amp;-d_isin(\alpha_{i-1})\\<br>sin(\theta_i)sin(\alpha_{i-1})&amp;cos(\theta_i)sin(\alpha_{i-1})&amp;cos(\alpha_{i-1})&amp;d_icos(\alpha_{i-1})\\<br>0&amp;0&amp;0&amp;1\<br>\end{bmatrix}$$</p><p>4）正解：</p><p>$${^b_e}{T}={^b_1}T\cdot{^1_2}T\cdot{…}\cdot{^n_e}T$$</p><p>5）逆解：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;就是通过不断调整（左乘与右乘）上面几个矩阵的位置，尝试找到可以单独求解的未知数即可。虽然有些繁琐，但是各位初学者一定要亲手推一遍六轴机械臂的运动学逆解公式，并<strong>编程实现</strong>。</p><h3 id="3-3-雅可比矩阵"><a href="#3-3-雅可比矩阵" class="headerlink" title="3.3 雅可比矩阵"></a>3.3 雅可比矩阵</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;雅可比矩阵 $J$ 是机器人学中一个非常重要的东西。它表示机器人关节速度 $\dot{q}$ 与末端速度 $\dot{x}$ 之间的关系:</p><p>$$\dot{x}=J\cdot \dot{q}$$</p><ul><li><p>如果你前面没有弄清楚角速度，建议在这章仔细思考。例如，「为什么不能直接对欧拉角求导获得速度？」；</p></li><li><p>了解教材中的雅可比计算方式，并思考「是否可以直接对运动学正解的结果求偏导？」</p></li><li><p>这边需要掌握的就是它的计算方法了，<strong>一定要</strong>编程计算机器人的雅可比矩阵；</p></li><li><p>如果你用 Matlab 或 Python，你可以利用他们的符号运算工具来验证我上面几个问题。从而加深对角速度的理解。</p></li><li><p>（PS：姿态和角速度无法直观理解很正常，因为它们不是在笛卡尔空间内，等后面学到更多数学，你们才能真正理解它。）；</p></li><li><p>如果你了解虚功原理，那么你又会知道雅可比也可以表示末端力与关节力矩的关系（这在以后力控等方面很有用）。</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，你有了雅可比矩阵，你就会发现，你知道怎么通过调节角度来控制末端运动了。这时候我们再回头看运动学逆解的问题。你会发现：「让机器人末端朝着目标位姿运动不就可以了？」。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNihAP.png"></p><!-- TODO: update this pic --><p>&nbsp; &nbsp; &nbsp; &nbsp;<br>是的，这就是机器人运动学的数值计算方式，你可以利用这个方法写一个机器人运动学的通用求解算法。具体可以看我在知乎上的回答 <a href="https://www.zhihu.com/question/41673569/answer/129670927" target="_blank" rel="noopener">MATLAB机器人工具箱中机器人逆解是如何求出来的</a>。</p><p>各位初学者<strong>务必</strong>亲手实现一遍这种算法，还是有些坑需要踩的。</p><p>当然，这个方法很简洁，但是也有它本身的问题：</p><ul><li><p>计算速度慢，需要多次迭代；</p></li><li><p>一次只能返回一组解；</p></li><li><p>可能会遇到奇异点等，结果无法收敛。</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，你可以顺便去了解一些奇异（Singularity）的问题，理解奇异性是机器人构形相关的属性，无法通过建模方式来消除。</p><h3 id="3-4-动力学"><a href="#3-4-动力学" class="headerlink" title="3.4 动力学"></a>3.4 动力学</h3><p>我相信，80% 的小伙伴是在这一章放弃的。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiHXj.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;对于多轴机器人的动力学，不论是采用牛顿欧拉还是拉格朗日法，都会<strong>显得</strong>异常复杂。再加上如果之前没学好理论力学，那么基本上是举步维艰了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;所以，我个人认为，先对这个部分有个基本概念就行，暂时不需要直接去碰六轴机器人的动力学：</p><ul><li><p>会用拉格朗日法计算三轴机械臂的动力学模型（三轴的求解还是在可接受范围内的）；</p></li><li><p>用牛顿欧拉法计算三轴机械臂的动力学模型，一定要<strong>编程实现</strong>（因为在高自由度情况下，牛顿法更容易通过编程实现，未来如果要做动力学，更可能是用牛顿欧拉、而非拉格朗日）；</p></li><li><p>了解转动惯量之类的物理意义，（在上面编程实现过程中，肯定会有相应的问题发生，如角速度与转动惯量的参考坐标系问题）；</p></li><li><p>大概知道机器人动力学都包含哪些部分（公式的形式、连杆动力学、关节动力学、重力影响、关节摩擦力、电机动力学等）。</p></li></ul><h3 id="3-5-控制"><a href="#3-5-控制" class="headerlink" title="3.5 控制"></a>3.5 控制</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，我们有了各种工具来求解机器人的运动学问题了，我们知道要让机器人到达任意状态的关节角度值。但是，如何让这些关节动起来？</p><p>&nbsp; &nbsp; &nbsp; &nbsp;首先，我们要知道，日常生活中的世界还是受牛顿力学统治的。</p><p>$$F = m \cdot a$$</p><p>要让一个东西动起来，就要给它施力。</p><p align="center">  <img width="800" src="https://s2.ax1x.com/2020/01/02/lNixhT.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;如果我们给定一个滑块的运动轨迹 $s(t)$，我们就可以计算出它整个轨迹的加速度 $\ddot{s}(t)$，进而计算出让滑块按照我们设想运动所需的力 $F(t) = m \cdot \ddot{s}(t)$。</p><p>换句话说，我们可以通过动力学计算出让机器人运动所需的每个关节力矩。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiBtK.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;而关节力矩，可以通过电机提供，对于直流电机，输出力矩与电流成正比。</p><p>但是，有几个问题：</p><ul><li><p>动力学好难算；</p></li><li><p>动力学参数好不准（转动惯量不好测、关节摩擦力不好算）；</p></li><li><p>还可能有各种外力（抓持的物体，关节动力学属性变化等）。</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;这就是控制算法的工作了。于是，大家会接触到传说的 PID 控制。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，又有问题：如果我们直接把关节目标位置发给 PID 控制器，那么每次都是一次阶跃响应。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNFiu9.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;在这里，建议有条件的小伙伴用单片机弄一个单轴伺服控制系统，有伺服电机（你可以控制电流、力矩、或者 PWM 占空比；步进电机、舵机就算了）、有编码器（可以反馈电机的角度）、有驱动器（能将数字指令转换成电机控制信号）、有控制器（STM32等单片机，可以给驱动器提供控制指令）。顺便可以了解一些通讯、中断、实时性的内容。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，感觉好像还是有什么不对，机器人运动好像是有加减速过程（右）的，而非一次阶跃（左）。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNFZ4K.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;这就是轨迹规划（Trajectory Planning），给定一些轨迹点，利用不同的函数来拟合这些轨迹。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候你又想到，既然 PID 和动力学都可以计算让机器人运动所需的力，只是动力学稍微有一些不准，那么有没有可能把它们结合在一起，先用动力学算一个基本准确的力矩，然后用 PID 消除不准确性造成的微小误差？</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiR0I.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;是的，于是你发现了基于动力学前馈的 PID 控制算法。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;Craig 书上剩下的其他一些部分，可以大概浏览一下，因为有不少内容已经比较旧了。</p><hr><hr><h2 id="四-实践-（DirtyYourHands）"><a href="#四-实践-（DirtyYourHands）" class="headerlink" title="四. 实践  （DirtyYourHands）"></a>四. 实践  （DirtyYourHands）</h2><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;看完 Craig 的书后，你应该对工业机器人的原理有了一个大概的概念，但是，你缺乏实际动手经验，不清楚如何将书上的东西应用到实际机器人上。机器人毕竟是一个实践性的学科，一直停留在理论，不仅无用、而且无趣。</p><p><strong>Get your hands dirty!</strong></p><h3 id="4-1-动手"><a href="#4-1-动手" class="headerlink" title="4.1 动手"></a>4.1 动手</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;如果是本科生的话，非常建议参加一些比赛，如 RoboMaster、飞思卡尔智能车大赛、电子设计大赛等；也可以加入学校的一些科技组织，例如清华的天空工厂。主要是熟悉各种电子电路、培养动手能力。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，以我的观察，很多科技比赛大牛，在理论学习上往往比较弱。这主要是因为科技比赛强调的是系统能力，决定比赛结果的往往是一些小 tricks，而非理论知识；而且，比赛容易让人产生一种虚假的充实感，每天都很忙碌，但是可能只是在重复低级工作。这两个原因很容易让人陷入 local minima，无法在理论方面更进一步。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;所以，我有个不成熟的小建议：参加比赛和学生科技活动的话，有过两次完整的经历就够了。之后应该迅速将重点转向理论学习。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;如果身边有可以玩的机器人硬件，也可以尝试玩一玩，或者在 RobotStudio/Vrep/Gazebo 里玩仿真的机器人。</p><h3 id="4-2-Penn’s-Robotics-Specialization"><a href="#4-2-Penn’s-Robotics-Specialization" class="headerlink" title="4.2 Penn’s Robotics Specialization"></a>4.2 Penn’s Robotics Specialization</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;在此之后，不妨抽出几个月时间，看看 Coursera 上宾夕法尼亚大学的 <a href="https://www.coursera.org/specializations/robotics" target="_blank" rel="noopener">Robotics</a> 专项课程。这个专项课程与机械臂或者工业机器人关系不大，但是由于机器人很多方面是相通的，所以非常建议看一看。</p><ul><li><p>Aerial Robotics：这门课主要是介绍四旋翼无人机的控制问题，其中的轨迹规划、姿态描述、控制等对机械臂的学习非常有帮助。而且，这门课的作业质量也非常高，提供了基于 Matlab 的数值仿真模块，可以让初学者直观地看到自己代码的控制效果。</p></li><li><p>Computational Motion Planning：这门课的水平感觉不如前一个，但是通过这门课可以大概知道机器人里有 Motion Planning 这个方向，同时大作业也包括了手写 A*、PRM、Potential Fileds 等基本的 Motion Planning 算法，同时可以大概了解一下 Collision Checking 的基本原理。</p></li><li><p>Mobility：这部分主要是介绍足式机器人的控制问题。通过这门课，一方面可以大致了解足式机器人控制的发展脉络，这样看起 Boston Dynamics 的视频也不会那么一脸懵逼了。同时，更重要的是，掌握机器人建模与控制的关系：一个简化的模型，也可能对控制起非常大帮助。</p></li><li><p>Perception：这门课质量非常不错，基本是介绍相机模型、多视几何之类的内容。这方面内容可以对大家未来从事 SLAM、3D 视觉、标定等方面的研究非常有帮助。学完之后，大家就可以做出类似<a href="https://mp.weixin.qq.com/s?__biz=MzA5MDE2MjQ0OQ==&amp;mid=2652786307&amp;idx=1&amp;sn=e71bbca67c7fa69081e863b62b9fd5b4#rd" target="_blank" rel="noopener">《AR原理演示》</a>文章中的效果了：</p></li></ul><p align="center">  <img width="400" src="AR.gif"></p><ul><li>Estimation and Learning：这门课从高斯分布开始，介绍了 Kalman Filter、Particle Filter 等在机器人状态估计中非常有用的工具。而且，这门课的大作业会让你从零开始编写 2D 地图重建的程序，你可以知道如何利用激光传感器信息获得下面这样的 2D 地图。</li></ul><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNi4tf.jpg"></p><h3 id="4-3-ROS"><a href="#4-3-ROS" class="headerlink" title="4.3 ROS"></a>4.3 ROS</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;到现在为止，你对机器人的基础知识有了一个比较完整的脉络，而且，也用 Matlab 实现了一些有趣的算法。但是，你发现，机器人是一个非常大的系统，作为初学者，不太可能从头开始一步步搭建机器人所需的各个算法模块。这时候，你就应该开始拥抱伟大的开源世界了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;很多人可能知道，有一个叫做机器人操作系统的开源项目 <a href="https://wiki.ros.org/" target="_blank" rel="noopener">(Robot Operating System, ROS)</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;对于学习 ROS，网上可能有不少教程了。但是，我感觉，很多机电、自动化方向的学生并不适合直接开始看 ROS。因为他们缺乏基本的 Linux、C++ 知识。所以，我推荐按照如下步骤进行学习：</p><ul><li><p><strong>Linux</strong>：如果完全没有 Linux 开发经验，我建议可以先安装 Ubuntu 系统，然后看 <a href="http://www.ee.surrey.ac.uk/Teaching/Unix/" target="_blank" rel="noopener">UNIX Tutorial for Beginners</a> ，熟悉基本的 Linux 使用方法。</p></li><li><p><strong>Github</strong>：ROS 的大多数项目都是托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 上的。所以，非常有必要学会使用 Github，学会用 git 管理自己的代码。而且也可以为开源项目做些修改。例如可以像我一样只是<a href="https://github.com/stack-of-tasks/pinocchio/pull/672" target="_blank" rel="noopener">删除多余的分号</a>。</p></li><li><p><strong>C++ 基础</strong>：如果你没有系统学习过 C++，建议先把这部分补齐，因为 ROS 的主要代码都是 C++ 实现的。这里，我推荐学堂在线上清华大学郑莉老师的课程<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+00740043X_2015_T2+sp/about" target="_blank" rel="noopener">《C++语言程序设计基础》</a>和<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+00740043_2x_2015_T2+sp/about" target="_blank" rel="noopener">《C++语言程序设计进阶》</a>。当然，学习 C++ 的时候就可以在 Ubuntu 下进行，安装一个 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> 是个不错的选择。</p></li><li><p><strong>数据结构</strong>：其实，上面的基础已经足够你学习 ROS 了，但是，为了未来的学习，可以在适当时候学习一些数据结构的知识。数据结构的话，我推荐学堂在线上清华邓俊辉老师 <a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184+sp/about" target="_blank" rel="noopener">《数据结构(上)》</a>与<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184_2X+sp/about" target="_blank" rel="noopener">《数据结构(下)》</a>。</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;现在，你就可以大胆地去看 ROS 了。作为开源项目，我认为最好的教程就是官网的教程 <a href="https://wiki.ros.org/ROS/Tutorials" target="_blank" rel="noopener">ROS Tutorials</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;首先，通过 Beginner Level 和 Intermediate Level 了解 ROS 基本的通讯机制、学会使用 catkin、roslaunch、Rviz 等基本工具。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;之后，就可以根据各自的研究兴趣去看不同模块了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;如果有条件，能够配合一些 ROS 支持比较好的平台进行研究的话，可以大大提高学习速度。例如 TurtleBot、Baxter、Universal Robot 之类的。（这就看每个人条件了。）</p><p>&nbsp; &nbsp; &nbsp; &nbsp;理论上，在 ROS 环境下，你可以从事绝大多数与实时控制无关的研究，如 SLAM、Navigation、Motion Planning 等。如果你从事的是更加底层的工作，（如控制器设计），目前 ROS 还无法胜任。（如果不清楚为什么，回顾一下实时操作系统、机器人控制方面的知识）。</p><hr><hr><h2 id="五-进阶-（Advanced）"><a href="#五-进阶-（Advanced）" class="headerlink" title="五. 进阶  （Advanced）"></a>五. 进阶  （Advanced）</h2><hr><p>&nbsp; &nbsp; &nbsp; &nbsp;至此，你已经是一个不错的机器人工程师了。但是，如果你想从事研发工作，就需要学习更多专业知识。当然，这部分就跟大家的研究方向关系比较密切了，我没法一一细说。只大概介绍一些。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;另外，非常建议入手一本《Springer Handbook of Robotics》<sup>[2]</sup>。接触一个新的领域时，在 Handbook 里找到相应的章节，通过它了解基本的大纲，并利用提供的参考文献快速补齐知识。</p><h3 id="5-1-数学"><a href="#5-1-数学" class="headerlink" title="5.1 数学"></a>5.1 数学</h3><p>这时候，你的数学基础基本不允许你更进一步了。所以，你需要补充数学知识。</p><ul><li><p><strong>数值计算方法</strong>：很多时候，我们都是通过计算机来实现算法功能的，所以，你必须了解基本的数值计算方法，如数值微分、数值积分等。这部分可以看《Numerical Methods for Engineers》<sup>[3]</sup></p></li><li><p><strong>凸优化</strong>：这个世界很多问题都不容易找到解析解，我们得用优化方法来计算。所以，你必须了解如何建立优化模型，并知道如何用代码进行求解。这里，我推荐 Stanford 的公开课<a href="https://lagunita.stanford.edu/courses/Engineering/CVX101/Winter2014/about" target="_blank" rel="noopener">《Convex Optimization》</a></p></li><li><p><strong>李群李代数</strong>：优化方法经常要使用梯度信息，但是，你发现很多时候你不知道怎么定义梯度。李群李代数是一个非常经典的数学工具，可以非常方便地描述 SO(3)、SE(3) 空间中的对象。到这里，你之前对于四元数、角速度之类的疑问将一扫而空。这部分的学习资料，我会在后面补充。</p></li></ul><h3 id="5-2-Modern-Robotics"><a href="#5-2-Modern-Robotics" class="headerlink" title="5.2 Modern Robotics"></a>5.2 Modern Robotics</h3><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNio9S.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;李群李代数对于很多工科学生可能一时无法接受。这里，我推荐从 Modern Robotics 开始，这是一本面向本科生的教材，非常浅显。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;你可以在<a href="http://hades.mech.northwestern.edu/index.php/Modern_Robotics" target="_blank" rel="noopener">网上</a>找到它的所有信息，Coursera 上也有对应的课程：<a href="https://www.coursera.org/specializations/modernrobotics" target="_blank" rel="noopener">《Modern Robotics》</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;上完这门课，你能掌握旋量（Screw）这一全新的建模方式，同时，你会发现机器人运动学、动力学建模变得如此简单、干净。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，你已经触碰到了一点点李群李代数。之后就可以去看一些针对工科生的李群李代数教材，如<a href="http://www.cis.upenn.edu/~jean/gbooks/manif.html" target="_blank" rel="noopener">《Notes on Differential Geometry and Lie Groups, I &amp; II》</a></p><h3 id="5-3-控制"><a href="#5-3-控制" class="headerlink" title="5.3 控制"></a>5.3 控制</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，你可能已经尝试搭建过一些机器人平台，了解了一些基本的控制理论。但是，你发现实际的机器人并不理想，动力学模型可能非常不精确。于是，你需要做机器人的<strong>参数辨识</strong>。于是，你可以去看 Khalil 的教材《Modeling, identification and control of robots》<sup>[4]</sup>。其中，你需要了解各种滤波算法（计算加速度）、各种数值优化算法。而且，如果需要对机器人的运动学参数进行标定，你会发现李群李代数可以非常方便地定义各种相关的雅可比。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;现在，你有了一个相对精确的动力学模型，但是你发现，在给机器人控制器做轨迹规划的时候，需要给出速度、加速度约束。你感觉这其中有什么不对。是的，机器人系统中实际上并不存在什么速度、加速度约束，我们所有的操作都是针对电机力矩的。也就是说，我们只有力矩约束。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;那么，问题来了：在力矩约束下，如何让机器人实现最快的运动。于是你就入了<strong>最优控制</strong>的坑。在这里，各种数值优化方法将非常有用。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;现在你能把单独的一个机器人控制好了，但你发现，机器人一旦跟环境发生接触，只用机器人模型就不够了。你需要对环境进行建模。但是，环境是无法精确建模的。于是，你开始学各种<strong>力控</strong>、<strong>阻抗控制</strong>之类的内容。相应地、你就可以实现一些所谓协作机器人的功能了:<a href="https://mp.weixin.qq.com/s/hkZjZItqyfwG6k0cwRm9kA" target="_blank" rel="noopener">《听说现在协作机器人很火，所以我也做了1/7个》</a></p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNi66H.gif"></p><h3 id="5-4-运动规划"><a href="#5-4-运动规划" class="headerlink" title="5.4 运动规划"></a>5.4 运动规划</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;现在，你能让机器人按照你的要求运动了。但是，你感觉机器人还是太难用了，必须人工指定经过的路径点，否则机器人可能就会与环境发生碰撞。你想，有没有可能让机器人自己找到这些路径点。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;于是，你来到了运动规划的领域。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，一个很自然的想法是，有没有可能直接构建一个目标函数，用优化的方法计算出需要的轨迹。但是，世界有时候并没有那么可爱。运动规划问题常常是一个非凸问题，无法优化直接求解。所以，对于机械臂，可以有各种 Sampling-based 算法；当然，也有人将其近似成多个凸问题进行优化求解，在比较简单的场景下效果还算不错。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;运动规划的大致介绍可以看我以前写过的文章：<a href="https://mp.weixin.qq.com/s/_fE760XxFlvrkzYEpslYvA" target="_blank" rel="noopener">《运动规划 | 简介篇》</a>。</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiLBn.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;更详细的介绍最好看教材，如《Principles of Robot Motion》<sup>[5]</sup> 和《Planning Algorithms》<sup>[6]</sup> 都是不错的教材。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;另外，这部分一定要配合着编程来做。<a href="http://ompl.kavrakilab.org/" target="_blank" rel="noopener">The Open Motion Planning Library</a> 是个不错的参考，相信你在学 ROS 的时候也或多或少了解过一些。</p><p>只要你理解得足够深入，便会理解前面李群李代数的作用。例如：</p><p>（1）运动规划是在 Configuration Space 里进行的，而大多数常见机构的 Configuration Space 都是一个 Lie Group：多关节机器人的关节空间（Torus(n)），无人机（SE(3)），机器人末端操作物体的相关约束（SE(3)）。于是，我们只要定义各种 Lie Group 的基本性质，就可以用统一的规划算法来进行规划了。具体可以看 Ompl 里 State space 的使用。</p><p>（2）当我们的规划涉及到一些约束，如让机器人末端保持水平（拿着一杯水）。一种方法是用传统的方法。如 OpenRave 里的一个实现：<a href="http://openrave.org/docs/0.8.2/openravepy/examples.constraintplanning/" target="_blank" rel="noopener">ConstraintPlanning</a>， 在关节空间随机采样一个点，然后投影到最近的任务空间上，之后用 Jacobian 迭代的方式将随机点连接到 RRT 树上。</p><p align="center">  <img width="300" src="https://s2.ax1x.com/2020/01/02/lNFFBR.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，我们可以从另一个角度看问题。机器人的末端姿态就是一个 SE(3) 李群。保持末端水平，可以认为是一个 R3 空间与 SO(2) 空间的半直积，这也是一个李群。于是，我们可以直接在李群内或者 Tangent Space 上跑一个 RRT，例如 Tangent Bundle RRT<sup>[7]</sup> 与 AtlasRRT<sup>[8]</sup></p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNispD.jpg"></p><h3 id="5-5-机器学习"><a href="#5-5-机器学习" class="headerlink" title="5.5 机器学习"></a>5.5 机器学习</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;前面很多工作都是在做建模+辨识的工作。实际上还有一大类工作是基于数据的，也即，给一个通用模型，用数据进行学习拟合。也就是大家常说的机器学习了。</p><p>对于此，我个人的学习路径如下：</p><ul><li><p>Coursera上吴恩达的<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="noopener">《机器学习》</a>，了解基本的机器学习内容。</p></li><li><p>Geoffrey Hinton 的<a href="https://www.youtube.com/playlist?list=PLoRl3Ht4JOcdU872GhiYWf6jwrk_SNhz9" target="_blank" rel="noopener">《Neural Networks for Machine Learning》</a>，之前是在 Coursera 上看的，现在似乎只能在 Youtube 上找到了。这门课基本可以把几种经典的神经网络过一遍。</p></li><li><p>各种开源平台。有了前面的基础，也在 Matlab 中实现过几种经典机器学习算法，你就可以去尝试一些深度学习开源平台了，如 <a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>。做机器学习的人太多了，所以资料也非常多，在网上非常容易自学。</p></li></ul><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，我们要知道，我们学机器学习，并不是为了转到 DL 方向上，而是用它来为机器人研究提供工具的：</p><ul><li><p>智能控制：相信学习过智能控制的小伙伴，应该还记得小脑模型之类的网络在控制中的应用；</p></li><li><p>建模：对于一些不好建模的地方，有时候不妨试试机器学习的方法，例如，用神经网络拟合摩擦力；</p></li><li><p>视觉：机器人经成需要跟视觉结合在一起，而 DL 在视觉领域发展迅速，有时候借用这一工具，可以非常快地搭建实验原型；</p></li><li><p>强化学习：这个下章介绍。</p></li></ul><h3 id="5-6-强化学习"><a href="#5-6-强化学习" class="headerlink" title="5.6 强化学习"></a>5.6 强化学习</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;如果研究过强化学习，肯定会被其极简的理论所折服：所有的理论衍生自一个 Bellman equation。而且，强化学习非常符合人的直觉。因此，很多人认为强化学习是机器人的未来方向。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;对此，我不做过多评论。我只大概介绍如何入门强化学习。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;首先，就是看书。Sutton 的《Introduction to reinforcement learning》<sup>[9]</sup> 可以说是必读圣经了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;你可以在 Github 找到 Python 版本的算法实现 <a href="https://github.com/ShangtongZhang/reinforcement-learning-an-introduction" target="_blank" rel="noopener">Python Implementation</a></p><p>&nbsp; &nbsp; &nbsp; &nbsp;阅读 Sutton 的书，你可以一步步了解如何从最初的 Bellman 方程推导出 Dynamic Programming、Monte Carlo、TD Learning 等方法。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;你知道了强化学习就是要通过不断尝试来学习得到一个从 State 到 Action/Value 的查找表。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;于是，你就想，有没有可能简化这个查找表，于是，你知道了有 Function Approximation。如果这个近似函数是神经网络，那么就是现在很火的 Deep Reinforcement Learing 了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，这些不重要。重要的是理解 Markov Decision Processes。你会发现，它不仅可以用来解决运动规划问题（DP ≈ Dijkstra、Monte Carlo ≈ RRT），还可以用来解决任务规划问题。</p><h3 id="5-7-最新论文"><a href="#5-7-最新论文" class="headerlink" title="5.7 最新论文"></a>5.7 最新论文</h3><p>&nbsp; &nbsp; &nbsp; &nbsp;至此，你已经能够阅读绝大多数最新的论文了。所以，你应该关注类似 RSS、ICRA、IROS 等相关会议，了解机器人领域的最新进展；通过 IJRR、TRO 等期刊学习最新的理论。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当然，你也可以通过 Google Scholar 订阅相应的关键词，它会不定期将最新的论文推送到你的邮箱。</p><hr><hr><h2 id="六-勇者斗恶龙-（DragonQuest）"><a href="#六-勇者斗恶龙-（DragonQuest）" class="headerlink" title="六. 勇者斗恶龙  （DragonQuest）"></a>六. 勇者斗恶龙  （DragonQuest）</h2><hr><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNFVN6.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;现在，你已经知道了如何让一个机器人动起来，并且深入掌握了机器人某一领域的知识。然后，你就像一个刚刚斩杀第一只史莱姆的勇者一般，举着宝剑，时刻准备着将宝剑刺入恶龙的胸口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，这时候有人跑过来，往你头上浇了一盆水：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;现在随便一个公司，花点钱请人画个机器人图纸，找工厂加工出来，买些电机、减速器之类的零部件，套上一个通用控制器就可以跑了。哪需要什么动力学、最优控制、运动规划呀！</p><p>&nbsp; &nbsp; &nbsp; &nbsp;就连四大家，机器人建模用 DH 就够了，最多做点运动学标定、动力学辨识，更多精力放在了应用集成上。哪需要什么李群李代数、凸优化、强化学习呀！</p><p><strong>「这世上哪儿有什么恶龙啊！」</strong></p><p>&nbsp; &nbsp; &nbsp; &nbsp;然而，我想说的是，就机器人这块，只要工农业这类体力劳动没有实现完全的自动化，恶龙就存在：</p><p align="center">  <img width="500" src="Teaching.gif"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;当你看到绝大多数机器人还是通过上面这样的方式，一点点示教出来的，你会有强烈的感觉：「这就是恶龙！」</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNFkH1.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;当你看到世界上那么多机器人公司，有着各自形形色色、互不兼容的编程语言、示教器的时候，你会有强烈的感觉：「这就是恶龙！」</p><p align="center">  <img width="500" src="https://s2.ax1x.com/2020/01/02/lNiy1e.jpg"></p><p>&nbsp; &nbsp; &nbsp; &nbsp;当你看到还有非常多与你我同龄的人在工厂里做着重复、枯燥的工作的时候，你会有强烈的感觉：「这就是恶龙！」</p><p>&nbsp; &nbsp; &nbsp; &nbsp;是的，在机器人领域，还有非常多恶龙。于是，你拿起剑，又兴冲冲地上路了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;忽然，你发现，你之前学的都是如何杀死一个「<strong>真空中的球形龙</strong>」，你不知道应该如何杀死一个真正的龙。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;所以，你应该继续学习。去找更多的史莱姆练手，将之前学到的剑法应用在实际战场上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;后来，你又遇到了新问题，你之前的宝剑并不具有「工业级强度」：ROS 经常崩、Orocos的没有处理 <a href="http://eigen.tuxfamily.org/dox/group__TopicStructHavingEigenMembers.html" target="_blank" rel="noopener">Eigen Alignment</a>、没有好用的 3D 传感器、工业机器人不开放底层接口等等。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;于是，你意识到，你需要重新打造自己真正的宝剑。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;但是，这不是你一个人可以做到的，你需要一个团队，有人挖煤、有人炼钢、有人打铁、有人磨刀……</p><p>&nbsp; &nbsp; &nbsp; &nbsp;这时候，不妨来 <a href="http://rvbust.com/" target="_blank" rel="noopener">RVBUST</a> 看看。</p><hr><hr><h2 id="七-参考文献-（References）"><a href="#七-参考文献-（References）" class="headerlink" title="七. 参考文献  （References）"></a>七. 参考文献  （References）</h2><hr><p>[1] John J. Craig. Introduction to Robotics: Mechanics and Control[M]. 1986.</p><p>[2] Siciliano, Bruno, and Oussama Khatib, eds. Springer handbook of robotics. Springer, 2016.</p><p>[3] Steven C. Chapra. Numerical Methods for Engineers (7th edition)[M]. 2014.</p><p>[3] Khalil, Wisama, and Etienne Dombre. Modeling, identification and control of robots. Butterworth-Heinemann, 2004.</p><p>[4] Choset, Howie M., et al. Principles of robot motion: theory, algorithms, and implementation. MIT press, 2005.</p><p>[5] LaValle, Steven M. Planning algorithms. Cambridge university press, 2006.</p><p>[6] Kim, Beobkyoon, et al. “Tangent bundle RRT: A randomized algorithm for constrained motion planning.” Robotica 34.1 (2016): 202-225.</p><p>[7] Jaillet, Léonard, and Josep M. Porta. “Path planning with loop closure constraints using an atlas-based RRT.” Robotics Research. Springer, Cham, 2017. 345-362.</p><p>[8] Sutton, Richard S., and Andrew G. Barto. Introduction to reinforcement learning. Vol. 135. Cambridge: MIT press, 1998.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机械工程 </tag>
            
            <tag> 学习方法 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
